; void assert(int expected, int actual, char *code)
.function internal int32 assert expected:int32 actual:int32 code:int8*
    ; if (expected == actual)
    ldarg.0
    ldarg.1
    ceq
    brfalse L_NOTEQ
    ; printf("%s => %d\n", code, actual);
    ldstr "{0} => {1}"
    ldarg.2
    call System.Runtime.InteropServices.Marshal.PtrToStringAnsi intptr
    ldarg.1
    box int32
    call System.Console.WriteLine string object object
    br L_EXIT
L_NOTEQ:
    ; printf("%s => %d expected but got %d\n", code, expected, actual);
    ldstr "{0} => {1} expected but got {2}"
    ldarg.2
    call System.Runtime.InteropServices.Marshal.PtrToStringAnsi intptr
    ldarg.0
    box int32
    ldarg.1
    box int32
    call System.Console.WriteLine string object object object
    ; exit(1);
    ldc.i4.1
    call System.Environment.Exit int32
L_EXIT:
    ldc.i4.0   ; HACK: Currently void type is not supported.
    ret

; void printf(char *arg)
.function internal int32 printf arg:int8*
    ldarg.0
    call System.Runtime.InteropServices.Marshal.PtrToStringAnsi intptr
    call System.Console.Write string
    ldc.i4.0   ; HACK: Currently void type is not supported.
    ret

; static int static_fn() { return 5; }
.function file int32 static_fn
    ldc.i4.s 5
    ret

; int strcmp(char *p, char *q);
.function internal int strcmp p:int8* q:int8*
LOOP:
    ldarg.0
    ldind.i1
    ldarg.1
    ldind.i1
    sub
    dup
    brfalse.s NEXT1
    ret
NEXT1:
    pop
    ldarg.0
    ldind.i1
    brtrue.s NEXT2
    ldc.i4.0
    ret
NEXT2:
    ldarg.0
    ldc.i4.1
    add
    starg.s 0
    ldarg.1
    ldc.i4.1
    add
    starg.s 1
    br.s LOOP

; int memcmp(char *p, char *q, long n);
.function internal int memcmp p:int8* q:int8* n:int64
    br.s ENTER
LOOP:
    ldarg.0
    ldind.i1
    ldarg.1
    ldind.i1
    sub
    dup
    brfalse.s NEXT
    ret
NEXT:
    pop
    ldarg.0
    ldc.i4.1
    add
    starg.s 0
    ldarg.1
    ldc.i4.1
    add
    starg.s 1
    ldarg.2
    ldc.i4.1
    conv.i8
    sub
    starg.s 2
ENTER:
    ldarg.2
    ldc.i4.0
    conv.i8
    bgt.s LOOP
    ldc.i4.0
    ret
